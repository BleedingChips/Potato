# PotatoEbnf

基于`PotatoSLRX`和`PotatoReg`的Ebnf库。

```cpp
import PotatoEBNF;
using namespace Potato::EBNF;
```


* 创建一个Ebnf

	```cpp
	std::u8string_view EbnfCode1 =
		u8R"(
	$ := '\s+'
	Num := '[1-9][0-9]*' : [1]

	%%%%

	$ := <Exp> ;

	<Exp> := Num : [1];
		:= <Exp> '+' <Exp> : [2];
		:= <Exp> '*' <Exp> : [3];
		:= <Exp> '/' <Exp> : [4];
		:= <Exp> '-' <Exp> : [5];
		:= '<' <Exp> '>' : [6];

	%%%%

	+('*' '/') +('+' '-')
	)";

	EBNFX Tab = EBNFX::Create(Table);

	auto TableBuffer = TableWrapper::Create(Tab); // 序列化版本
	```

	一个Ebnf由三部分组成，其中以`%%%%`为分割符。

	1. 词法区

		其语法规则为：

		> `终结符` `=` `正则表达式` [`:` `标记值`] (可选)。
		
		> `$` `=` `正则表达式`

		以`$`为终结符的词法讲会被作为分隔符，被标记为分割符的词语将不会进入到后续的语法分析中。

	2. 语法区

		其语法规则为
		
		> [`非终结符`] (可选) `:=` `终结符`/`非终结符`/`常量字符串`/`标记值`/`$` ... [`:` `标记值`] (可选) `;` 

		其中`标记值`为一串数字，若跟在在一个非终结符后面，则表示防止该终结符由标记的产生式规约，若跟在产生式后，则表示标记该产生式。

		若`$`跟在一个非终结符后面，则表示防止该终结符由自身产生规约。

		当产生式左部为空时，则表示该产生式的左部为上一个产生式的左部。

		> `$` `:=` `非终结符`[`标记值`] (可选) `;`

		标记开始符号，标记值则表示当前最多支持`LR(X)`的文法。

		在产生式的右部，还支持Ebnf语法，如：
		
		> `终结符`/`非终结符`/`常量字符串`/`标记值`/`$` ... `|` `终结符`/`非终结符`/`常量字符串`/`标记值`/`$` ...

		> `[` `终结符`/`非终结符`/`常量字符串`/`标记值`/`$` ... `]`

		> `{` `终结符`/`非终结符`/`常量字符串`/`标记值`/`$` ... `}`

	3. 运算符优先级区

		该区可为空。

		一般语法规则为：

		> `+(` `常量字符串`/`终结符` ... `)`

		> `(` `常量字符串`/`终结符` ... `)+`

		在同一`()`内的所有`常量字符串`/`终结符`为相同优先级，在前面的`()`的优先级大于后面的`()`，`+()`表示左结合，`)+`表示右结合。

	示例：

	```cpp
	std::wstring_view EbnfCode1 = LR"(
		Num := '[1-9][0-9]*' : [1];
		$ := '\s+';

		%%%%

		$ := <Exp> ;

		<Exp> := Num : [1];
			:= <Exp> '+' <Exp> : [2];
			:= <Exp> '*' <Exp> : [3];
			:= <Exp> '/' <Exp> : [4];
			:= <Exp> '-' <Exp> : [5];
			:= '<' <Exp> '>' : [6];

		%%%%

		+('*' '/');
		+('+' '-');
	)";
	```